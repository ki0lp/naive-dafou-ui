---
title: springmvc基础
date: 2020/5/02
description: springmvc基础概述
category: 核心
tag: [Java, Java web, springmvc]
---

## 环境搭建

### tomcat

#### 安装

1. 官网选择想要安装的版本下载

![](./01.springmvc基础.assets/16366557984077.jpg)

2. 下载之后解压到自己想要的目录

3. 需要将Tomcat目录下的bin设置为可执行状态

![](./01.springmvc基础.assets/16366558133551.jpg)

4. 进入bin目录执行./starup.sh

![](./01.springmvc基础.assets/16366558335583.jpg)

![](./01.springmvc基础.assets/16366558369037.jpg)

### idea

#### idea配置Tomcat

![](./01.springmvc基础.assets/16366558594354.jpg)

![](./01.springmvc基础.assets/16366558633582.jpg)

![](./01.springmvc基础.assets/16366558676174.jpg)

![](./01.springmvc基础.assets/16366558714811.jpg)

![](./01.springmvc基础.assets/16366558746253.jpg)

修复下面的warning

![](./01.springmvc基础.assets/16366558923936.jpg)

![](./01.springmvc基础.assets/16366558967423.jpg)

services表示成功了

#### 设置热部署

![](./01.springmvc基础.assets/16366559928002.jpg)

这个支持得不是很好

#### maven项目运行的时候target或者out中缺少文件（比如自己写的class、配置文件、jar包等）

1. 如果是缺少jar包，需要把在project structure->Artifacts把右边的jar右键添加到lib目录中

![](./01.springmvc基础.assets/16366566570305.jpg)

2. 如果是缺少了自己编译的class或者配置文件

在Project Structure下先把traget目录删除

![](./01.springmvc基础.assets/16366567289578.jpg)

执行下Reimport

![](./01.springmvc基础.assets/16366567356838.jpg)

重新install下

![](./01.springmvc基础.assets/16366567393201.jpg)

结果

![](./01.springmvc基础.assets/16366567536673.jpg)



## 概述

### 介绍

#### mvc三层架构

![](./01.springmvc基础.assets/16366568391899.jpg)

上方是三层架构，下方是MVC架构，两者类似，所以才会把三层结合起来介绍

#### springmvc

##### 官网

![](./01.springmvc基础.assets/16366571064277.jpg)

![](./01.springmvc基础.assets/16366571096570.jpg)

##### 介绍

- 是构建在servlet API上的原始web框架，来自于模块spring-webmvc
- springvmvc是spring框架的一部分，是基于Java框架的一个轻量级的web框架
- 学习springmvc框架就是最核心的就是DispatcherServlet的设计，掌握好DispatcherServlet是掌握springmvc的核心关键

![](./01.springmvc基础.assets/16366571777753.jpg)

如果是使用maven构建的话，只需要引入spring-webmvc即可，因为webmvc会自动引入spring-web，因为spring-webmvc依赖于spring-web

##### 优点

![](./01.springmvc基础.assets/16366573963394.jpg)

##### 实现原理

###### DispatcherServlet：前端控制器

作用是将请求分发不到不同的处理器，实际上是一个Servlet，他继承字HttpServlet基类，它是中间商、快递中心

![](./01.springmvc基础.assets/16366575258749.jpg)

###### springmvc的具体执行流程

当发起**请求**被**前置控制器**拦截到请求，根据请求参数生成代理请求，找到请求对应的**实际控制器**，控制中心处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用**模型**与**视图**渲染结果，将结果返回给中心控制器，再将结果返回给请求者

![](./01.springmvc基础.assets/16366577045111.jpg)

执行流程

- DispatcherServlet表示前端控制器，是整个springmvc的控制中心，DispatcherServlet接收请求并拦截请求
- HandlerMapping为处理器映射，DispatcherServlet调用HandlerMapping，HandlerMapping根据请求url查找Handler
- 返回处理执行链，根据url查找控制器，并且将解析后的信息传递给DispatcherServlet
- HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler找到具体的处理器
- Controller执行业务操作，访问Service、访问数据库操作等
- Controller将具体的执行信息返回给HandlerAdapter，如ModelAndView
- HandlerAdapater将视图逻辑名或模型传递给DispatcherServlet
- DispatcherServlet调用视图解析器（ViewResolver）解析HandlerAdapter传递的逻辑视图
- ViewReslover根据ModelAndView里面的视图名地址去找具体的jsp封装到View对象中，传给DispatcherServlet
- 带有数据和jsp的ViewView进行渲染（将jsp转换成html内容）最终response到客户端

### springmvc项目搭建

#### 创建maven项目

![](./01.springmvc基础.assets/16366587440599.jpg)

#### 添加依赖

![](./01.springmvc基础.assets/16366587524179.jpg)

![](./01.springmvc基础.assets/16366587561430.jpg)

点击maven刷新

![](./01.springmvc基础.assets/16366587693634.jpg)

maven自动帮我们把spring-webmvc依赖的一些jar包导入了，包括底层的core\context\beans\expression，以及它自身依赖的web等，而jcl是spring的日志使用

#### 将项目改造成web项目

![](./01.springmvc基础.assets/16366591589628.jpg)

![](./01.springmvc基础.assets/16366591625101.jpg)

#### 配置DispatchServlet

提供了两种方式：

- 不用web.xml，直接使用Java配置类
- 使用web.xml

web.xml的方式，在web.xml中添加servlet，接收除了jsp的请求都交给springmvc处理

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">
    
    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:spring-mvc.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

**url匹配的机制**

![](./01.springmvc基础.assets/16366596652940.jpg)

一般用第一种了

#### 配置spring容器

官网有一个约定大于配置的，所以只要创建的spring配置文件的时候，按照官网的命名就可以不用配置，但是我们这里配置一下

> 约定：会自动去找WEB-INF中的[servlet-name]-servlet.xml的约定文件

告诉springmvc的spring的配置文件

```xml
<servlet>
    <servlet-name>springmvc</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
        <!--告诉springmvc的spring容器的配置文件-->
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:spring-mvc.xml</param-value>
    </init-param>
    <!--设置启动服务器的时候就加载spring容器，tomcat启动的时候会调用servlet的构造函数，然后spring容器初始化-->
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>springmvc</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>
```

`org.springframework.web.servlet.DispatcherServlet`继承

在spring-mvc.xml中配置自动扫描指定的包，将包中的标注了指定的注解的类注入到spring容器中

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">
    <!--自动扫包-->
    <context:component-scan base-package="com.ald.springmvc"/>

</beans>
```

#### 创建Controller，并注入到spring容器中

编写测试用的Controller

```java
@Controller
public class HelloController {
    @RequestMapping("/hello")
    public String hello(String name){// 自动匹配请求的参数值
        System.out.println("hello "+name);
        // redirect：重定向，不写的话默认是转发
        return "redirect:index.jsp";
    }
}
```

#### 运行测试

![](./01.springmvc基础.assets/16366611759940.jpg)

![](./01.springmvc基础.assets/16366613857721.jpg)

##### 出现的错误处理

1. 端口冲突

![](./01.springmvc基础.assets/16366612167772.jpg)

关闭这个端口

2. 找不到资源

![](./01.springmvc基础.assets/16366612381794.jpg)

排错过程：看编译之后的目录out下

![](./01.springmvc基础.assets/16366612796948.jpg)

通常web项目所有的jar包应该编译到WEB_INF的lib目录下

解决方式：

![](./01.springmvc基础.assets/16366613317020.jpg)

将所有的jar添加到lib目录下，之后Apply

![](./01.springmvc基础.assets/16366613081618.jpg)

### springmvc-helloworld的运行流程

- 客户端发送请求
- 由Tomcat接收到对应的请求，通过我们在web.xml配置的DispatcherServlet，将这个请求交给DispatcherServlet处理，然后就是上面说的springmvc的处理步骤了
- springmvc的前端控制器DispatcherServlet接收到所有的请求
  查看请求地址和@RequestMapping注解的哪个匹配，来找到具体的类的处理方法
- 前端控制器找到目标类和处理方法之后，执行目标方法
- 方法执行完成之后会有一个返回值，springmvc会将这个返回值用视图解析器拼接成完整的页面地址
- DispatcherServlet拿到页面地址之后，转发到具体的页面

## 请求处理

### 请求参数处理

#### 对请求参数的处理

> 400的错误时参数类型未匹配

##### @RequestParam

之前servlet api：request.getParameter("name")，在springmvc中只需要在处理方法中声明对应的参数就可以自动接收请求的参数并且还可以自动类型装换，这用于接收get上的`?name=张三&id=11`和接收post表单中的参数。

1. 匹配规则

- 请求的参数必须跟处理方法的参数名一致
- 如果处理方法的参数未传入的情况会自动传入null
- 不要用基础数据类型，因为基础数据类型无法接收null

2. 如果请求的参数跟处理方法的参数不一致的情况

可以利用`@RequestParam("username")`管理请求参数，如果用这个注解之后，必须要传入值，否则会报错

![](./01.springmvc基础.assets/16366627820219.jpg)

@RequestParam的属性值

- value 用来重命名参数 可以省略
- required 用来指定参数是否必须传入值
  - 默认是true 必须传入，如果没有传入则会报400的错误
  - false 可以不用必须传入值
- defaultValue 默认值，当参数为null的时候会自动设置一个值，当设置了默认值可以省略required=false，也就是设置了默认值就是不是必须的传入的

```java
/**
 * 获取简单参数
 * @param name
 * @return
 */
@RequestMapping("/params01")
public String params01(@RequestParam(value = "username",required = false) String name){
    System.out.println(name);
    return "/index.jsp";// /加不加都一样的
}
```

3. 表单复杂数据的提交

![](./01.springmvc基础.assets/16366639801451.jpg)

数组也可以加上下标

要填充接收的实体类

![](./01.springmvc基础.assets/16366640272237.jpg)

处理请求的函数

```java
/**
 * 获取复杂参数
 * @param user
 * @return
 */
@RequestMapping("/params02")
public String params02(@RequestParam(value = "user",required = false) User user){
    System.out.println(user);
    return "/index.jsp";
}
```

总结

- 如果是包装类型是简单变量 直接输入属性名字=表单元素的name，比如`name="id"`
- 数组 保证这一组的表单元素都是同样的name，比如`name="alias"`
- list 必须加上 [索引]，比如`name="hibbies"`，`name="friends[0].name"`，这里的friends泛型是实体对象，所以要赋值的话，用.的方式
- map 必须加上 [key]，比如`name="relatives['father']"`
- 实体类 只能给某个属性赋值，比如`name="role.name"`
- 如果出现多个对象参数的情况，建议再次封装一层JavaBean（DTO：data transfer object）
  - 比如 `User user`,`Role role`
  - 比如 `List<User>`

> UserDTO：命名方式，DTO表示只用于数据传输

##### @RequestHeader

获取前端传输过来的请求头信息

用例：

- 获取Host
- 防盗链：获取Referer，查看是否是自己的域名

比如：

```java
/**
 * 获取请求头参数
 * @param host
 * @return
 */
@RequestMapping("/header")
public String header(@RequestHeader("Host") String host){
    System.out.println(host);
    return "/index.jsp";// /加不加都一样的
}
```

##### @CookieValue

servlet中获取cookie的方式：`Cookie[] cookies = request.getCookie()`

springmvc中获取cookie

```java
/**
 * 获取请求头参数
 * @param jSessionId
 * @return
 */
@RequestMapping("/cookie")
public String cookie(@CookieValue("JSESSIONID") String jSessionId){
    System.out.println(jSessionId);
    return "/index.jsp";// /加不加都一样的
}
```

如果想要获取所有的Cookie，就直接使用一个Map去接收就可以了

#### 乱码问题的解决

##### get请求

直接设置tomcat目录下的conf/server.xml

![](./01.springmvc基础.assets/16366660681227.jpg)

##### post请求

在servlet时期，在获取参数前，设置request.setCharacterEncoding("UTF-8")，但是在每个处理方法中都设置一遍太麻烦，所以会用过滤器来处理编码问题（终极的处理方式）

过滤器的处理机制：

![](./01.springmvc基础.assets/16366660917811.jpg)

spring提供了`CharacterEncodingFilter`来设置编码集，这个过滤器要写在其他的过滤器的前面（先处理乱码的问题）

在web.xml中配置：forceEncoding同时开启请求和响应的编码

```xml
<!--配置编码过滤器 CharacterEncodingFilter-->
<filter>
    <filter-name>characterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <!--设置编码-->
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
    <init-param>
        <!--设置是否覆盖当前请求和响应的编码-->
        <param-name>forceEncoding</param-name>
        <param-value>true</param-value>
    </init-param>
</filter>
<!--配置拦截那些请求进行过滤-->
<filter-mapping>
    <filter-name>characterEncodingFilter</filter-name>
    <!--拦截规则-->
    <!--<url-pattern></url-pattern>-->
    <!--因为所有的请求都会通过DispatcherServlet，所以直接拦截springmvc进行编码-->
    <servlet-name>springmvc</servlet-name>
</filter-mapping>
```

在web.xml中配置：forceEncoding同时开启请求和响应的编码

```源码中的解释
/**
 * Create a {@code CharacterEncodingFilter} for the given encoding.
 * @param encoding the encoding to apply
 * @param forceEncoding whether the specified encoding is supposed to
 * override existing request and response encodings
 * @since 4.2.3
 * @see #setEncoding
 * @see #setForceEncoding
 */
public CharacterEncodingFilter(String encoding, boolean forceEncoding) {
	this(encoding, forceEncoding, forceEncoding);
}
```

配置的两个属性：

- encoding - 要应用的编码
- forceEncoding – 指定的编码是否应该覆盖现有的请求和响应编码

过滤器会执行doFilterInternal函数，只要设置框中的几个判定，就可以设置编码

![](./01.springmvc基础.assets/16366668904222.jpg)

#### 对原生API的支持

springmvc除了自己在servlet的基础之上包装了servlet底层的api之外，还针对底层的api进行了支持

需要先引入servlet的包，也就是Tomcat中的jar包

![](./01.springmvc基础.assets/16366669373660.jpg)

![](./01.springmvc基础.assets/16366669415299.jpg)

![](./01.springmvc基础.assets/16366669452731.jpg)

如果在使用servlet原生的api的时候找不到类，查看一下是否没有引入

测试使用servlet中的`HttpServletRequest`和`HttpServletResponse`

```java
/**
 * 获取请求头参数
 * @param request
 * @return
 */
@RequestMapping("/servlet")
public String servlet(HttpServletRequest request, HttpServletResponse response){
    String name = request.getParameter("name");
    System.out.println(request);
    System.out.println(response);
    return "/index.jsp";// /加不加都一样的
}
```

### 请求映射处理

#### @RequestMapping


`@Target({ElementType.TYPE, ElementType.METHOD})`，可以注解在类和方法上

用来处理url映射，将请求映射到处理方法中，可以标在方法上（对应该方法唯一链接）；也可以标在类上（对应链接模块处理）

从spring4.3开始提供了一套简写的方式，@RequestMapping(value="/url",method=RequestMethod.GET)等于@GetMapping(value="/url")

![](./01.springmvc基础.assets/16366703336747.jpg)

```java
@PostMapping("/mapping01")
public String mapping01(){
    System.out.println("映射成功");
    return "/index.jsp";
}
```

##### @RequestMapping属性

1. name：命名专用，没有什么作用

2. value：设置请求的url映射

```java
@AliasFor("path")// 是path的别名
String[] value() default {};// {} 表示接收的单个或者多个键值对，也就是说可以处理多个url映射到该函数上
```

3. path 等价于value

```java
@AliasFor("value")//是value的别名
String[] path() default {};// {} 表示接收的单个或者多个键值对，也就是说可以处理多个url映射到该函数上
```

4. method

设置请求方式GET/POST/PUT/DELETE...，可以设置多个请求方式，如果不写就可以匹配所有的请求方式

```java
@RequestMapping(value = "/mapping01",method = RequestMethod.POST)
```

```java
RequestMethod[] method() default {};//可以处理多个不同协议的请求，GET/POST/...
```

5. params：设置请求必须携带某些参数，映射请求的参数

缩小主映射的范围。适用于任何环境的相同格式：一系列“myParam=myValue”样式表达式，只有在发现每个此类参数具有给定值时才映射请求。

必须要有某些参数，必须要有username参数

![](./01.springmvc基础.assets/16366685067389.jpg)

必须没有某些参数，必须没有username

![](./01.springmvc基础.assets/16366690880857.jpg)

参数必须要等于什么值

![](./01.springmvc基础.assets/16366690965776.jpg)

参数必须要不等于什么值

![](./01.springmvc基础.assets/16366691050848.jpg)

示例：

```java
@GetMapping(value = "/params",params = {"username!=张三"})
public String mapping02(){
    System.out.println("映射成功");
    return "/index.jsp";
}

@GetMapping(value = "/params",params = {"username=张三"})
public String mapping04(){
    System.out.println("映射成功");
    return "/index.jsp";
}
```

前端的请求都是`http://localhost:8080/springmvc02/mapping/params`，如果是在后面拼接`?username!=张三`会执行mapping02方法；如果后面拼接的是`?username=张三`会执行mapping04方法

6. headers：请求头必须包含某些值

比如：必须当Accept-Language为zh-CN,zh;q=0.9

```java
@GetMapping(value = "/header",headers = {"Accept-Language=zh-CN,zh;q=0.9"})
public String mapping03(){
    System.out.println("映射成功");
    return "/index.jsp";
}
```

7. consumes：当前的请求的内容类型必须为指定的值

通过entype设置，也就是请求头里面的Content-Type

![](./01.springmvc基础.assets/16366702019375.jpg)

- 第一个是form表单提交的文件流
- 第二个是form表单提交的数据类型，默认提交类型
- 第三个是ajax

8. produces：设置当前响应的内容类型

导出Excel、pdf、图片、视频等等，想看支持那些类型可以看tomcat下的conf/web.xml

![](./01.springmvc基础.assets/16366702626385.jpg)

##### URL通配符

映射的URL还可以支持通配符

- ? ：一个?匹配单个字符（a-z0-9）[1]
- \*：一个\*匹配任意个字符（a-z0-9）[任意个]
- \*\*：\*\*匹配任意字符任意层次的请求   user/\*\*/ ==user/ad/d/d/df/f/...
  ![](./01.springmvc基础.assets/16366710444239.jpg)

如果映射存在包含关系，映射的时候会交给更细粒度的处理，比如`localhost:8080/mapping/ant1`会先交给ant?处理，而不是ant*

![](./01.springmvc基础.assets/16366711676538.jpg)

如果报这个错误，表示配置了method，但是类型不是当前请求的类型，可能是其他的get、post、put、delete等

![](./01.springmvc基础.assets/16366712661190.jpg)


#### @PathVariable

如果需要在请求路径中的字符作为参数可以使用@PathVariable注解，提供了对占位符URL的支持，就是将URL中占位符参数绑定到控制器处理方法的参数中。

如果是单个参数的话，要是@PathVaribale修饰

```java
@GetMapping("/user/{id}")
public String get(@PathVariable("id") Integer id){
    System.out.println(id);
    return "/index.jsp";
}
```

![](./01.springmvc基础.assets/16366721917762.jpg)

如果是对象的话，可以不用加，给出的url是：user/id/name

```java
@PostMapping("/user")
public String add(User user) {
    System.out.println(user);
    return "/index.jsp";
}
```

#### REST

客户映射到服务器资源的一种架构设计，面向资源，然后通过get\post\put\delete去发送请求，命名规则

![](./01.springmvc基础.assets/16366725593406.jpg)

代码示例

```java
@Controller
@RequestMapping("/rest")
public class RestController {

    //查询
    @GetMapping("/user/{id}")
    public String get(@PathVariable("id") Integer id){
        System.out.println(id);
        return "/index.jsp";
    }

    @PostMapping("/user")
    public String add(User user) {
        System.out.println(user);
        return "/index.jsp";
    }

    @PutMapping("/user/{id}")
    public String update(User user) {
        System.out.println(user);
        return "/index.jsp";
    }

    @DeleteMapping("/user/{id}")
    public String delete(@PathVariable("id") Integer user) {
        System.out.println(user);
        return "/index.jsp";
    }
}
```

html是不支持put和delete协议的，但是http是支持的，当使用put和delet协议时，html不认识，就默认使用get请求，ajax是支持put\delete的协议的

为了能在解决上面html不能发送put和delete协议，解决思路是：

- 暂时将put和delete都设置成post
- 提交的时候，如果是post请求就在表单里面加一个隐藏域（hidden）将隐藏域设置成put\delete请求协议，经过过滤器判断当前请求是不是post，并且从表单中找到隐藏域，将当前的请求设置为对应的协议

springmvc提供了上面说的过滤器：`org.springframework.web.filter.HiddenHttpMethodFilter`

doFilterInternal方法说明了：在表单里面加一个name=”_method“的隐藏域

![](./01.springmvc基础.assets/16366727844523.jpg)

![](./01.springmvc基础.assets/16366727887853.jpg)

将springmvc提供的过滤器配置到web.xml文件中

```xml
<!-- 处理rest中put和delete不支持的解决方案，只有html表单才不支持put\delete -->
<filter>
    <filter-name>hiddenHttpMethodFilter</filter-name>
    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>hiddenHttpMethodFilter</filter-name>
    <servlet-name>springmvc</servlet-name>
</filter-mapping>
```

##### 出现异常的解决方式

![](./01.springmvc基础.assets/16366730924902.jpg)

解决办法

1. 用Tomcat7
2. 不用转发（服务器内部行为），用重定向（服务器通知浏览器重新发起新请求）

![](./01.springmvc基础.assets/16366738204837.jpg)

3. 将jsp的page指定isErrorPage属性改成true，不建议这么做
4. 自己写一个过滤器，将request.method改为POST

怎么在selvet回来之后在过滤器中写代码

![](./01.springmvc基础.assets/16366738607873.jpg)

![](./01.springmvc基础.assets/16366738663762.jpg)

##### 转发和用重定向的选择

什么时候用转发，什么时候用重定向？

- 查询数据用转发，因为要转发给jsp去展示数据
- 新增、删除、更新用重定向，展示操作的结果

#### 静态资源的访问

之前配置的DispatcherServlet时，除了jsp的都会被拦截掉，所以静态资源无法访问，然后会跟Controller做映射，如果没有匹配到就会报404错误

![](./01.springmvc基础.assets/16366741848969.jpg)

不能访问

![](./01.springmvc基础.assets/16366742009630.jpg)

控制台报错

![](./01.springmvc基础.assets/16366742053328.jpg)

只需要在spring-mvc.xml中配置即可

```xml
<!--配置访问静态资源
    将映射的地址直接指向静态资源文件夹，springmvc将不会将此映射作为handler
-->
<mvc:resources mapping="/images/**" location="/images/"/>
```

或者使用默认servlet当springmvc没有映射到某一个请求的时候，就会调用serlvet处理

```xml
<mvc:default-servlet-handler/>
```

## 响应数据

### 视图控制器（ViewResolver）

使用默认内置的视图控制器（ViewResolver）

![](./01.springmvc基础.assets/16366805655483.jpg)

虽然可以不用配置默认的视图解析器，但是即使是使用默认值的视图解析器，还是要配置一些东西，因为最好是让所有的数据都经过DispatcherServlet，这样可以保证数据是真实被填充到jsp页面

在实际开发过程中，最好把jsp的数据放到WEB-INF中，这时候用户就不能直接访问到jsp页面了

这个时候可以直接去除固定的jsp路径

### 视图控制器（ViewController）

如果我们有些请求只是想跳转页面，不需要后台处理什么逻辑，我们无法在Action中写一个空方法来跳转，直接在配置一个如下的视图跳转控制器即可（不经过Action，直接跳转页面）

比如：配置主页直接访问，不需要经过DispatchServlet

![](./01.springmvc基础.assets/16366812814881.jpg)

### 传输数据到页面

使用model\map\modelandmap对象传输数据到页面

1. Model

Model的底层还是request

![](./01.springmvc基础.assets/16366812996427.jpg)

2. ModelMap

![](./01.springmvc基础.assets/16366813220469.jpg)

3. Map

![](./01.springmvc基础.assets/16366813561525.jpg)

4. 三者的关系

![](./01.springmvc基础.assets/16366813772876.jpg)

#### ModelAndView

使用ModelAndView对象传输数据到页面

![](./01.springmvc基础.assets/16366814721062.jpg)

#### session

使用session传输数据到页面，推荐servlet api使用注入的方式

##### servlet api方式

如果在每个方法上都使用Session形参，这就形成了强耦合了session，可以通过组合的方式注入

![](./01.springmvc基础.assets/16366815259701.jpg)

##### springmvc注解方式

1. @SessionAttributes

用在类上，**写入session**

![](./01.springmvc基础.assets/16366815880880.jpg)

它会根据设置属性去方法中的model去找到对应的值，比如下面设置type，那么就会去方法中找到对应的type属性的对应值，复制一份到session中

![](./01.springmvc基础.assets/16366816736315.jpg)

可以设置多个，是个数组

当前控制器下的所有方法都会将model指定的属性写入session中

2. @SessionAttribute

用在参数上面，**读取session**，假如第一次去访问这个函数，它会报错，因为没有session，所以应该设置required=false

![](./01.springmvc基础.assets/16366817401847.jpg)

当使用注解的时候，session和model是互通的，session可以通过model中取获取写入指定的属性，model也会从session中自动写入指定的属性

**springmvc除了以上几种设置model到request域中的几种方式之外，springmvc还会隐式的将请求绑定的参数自动设置到request域中**

### ModelAttribute

使用@ModelAttribute来获取请求中的数据

用于将方法的参数或者方法的返回值绑定到指定的模型属性上，并返回给web视图

常用的使用场景

1. 写在方法上，让所有的处理方法调用之前调用@ModelAttribute的方法

这个类Controller中的所有方法都会先调用这个方法

![](./01.springmvc基础.assets/16366827512778.jpg)

a. 通过@ModelAttribute来给全局变量赋值，设置servlet api--session（不推荐）

![](./01.springmvc基础.assets/16366827785674.jpg)

b. 在update更新的时候，如果是通用的sql（全属性更新），需要在更新之前查出密码并赋值给需要更新的实体类（不推荐，最好是自己写更新sql）

当前端更新表单是，有隐藏域的id和待修改的用户名，如果是通用的全字段更新的sql那么就会将password修改成空的，所以在更新之前，查询数据库出user合并到待更新的user

![](./01.springmvc基础.assets/16367145162141.jpg)

springmvc有个特性

- 接收的形参会跟请求进来的参数合并，如果形参的user中的属性有值并且重复了就覆盖，如果没有就插入属性
- springmvc在进行参数绑定的之前，会将model中跟参数名重合属性拿出来进行合并，新提交的字段会覆盖，确实的字段会保留

总结：@ModelAttribute在方法上的使用场景

![](./01.springmvc基础.assets/16367146288562.jpg)


2. 写在参数上

可以省略，加上则会从model中获取一个指定的属性和参数进行合并，因为model和sessionAttribute具有共通的特性，所有如果session中有对应的属性，也会进行合并

![](./01.springmvc基础.assets/16367147438123.jpg)

### Servlet api线程安全

引出问题：springmvc的控制器是不是单例？如果是单例的会不会有线程安全问题？那么该如何解决？

线程不安全=并发问题：同一个时间，多个线程，同时对数据/变量/资源进行读写操作，就会产生并发问题（脏读、不可重复读、幻读）

三种获取方式：

1. 通过参数绑定的方式

![](./01.springmvc基础.assets/16367148755669.jpg)

- 是线程安全的
- 不是共享变量
- 因为参数绑定的方式变量是方法级别的，所以每次请求方法都会在内存中开辟自己独立的空间

2. 通过@Autowired

![](./01.springmvc基础.assets/16367149125217.jpg)

- 是线程安全的
- 虽然说它是共享变量，但是springmvc的底层通过ThreadLocal来存储serlvet api，所以通过自动注入进来的servlet api是线程安全的
- 是单例类级别的变量

3. 通过@ModelAndView

![](./01.springmvc基础.assets/16367149490509.jpg)

- 不是线程安全的
- 因为HttpSession它是共享变量，会对共享变量同时进行读写

### 使用forward实现页面转发

由服务器的页面进行跳转，不需要客户端重新发送请求，当我们什么都不规定的时候（不表明是使用转发还是重定向的时候），默认就是进行转发，会参与视图解析器。可以显式加上forward进行转发，forward需要自己返回完整视图逻辑名和路径，不会参与视图解析器解析。

![](./01.springmvc基础.assets/16367150056951.jpg)

特点如下

- 地址栏的请求不会发生任何变化，显示的还是第一次请求的地址
- 只有一次请求
- 请求域（request）中的数据不会丢失
- 根目录：localhost:8080/项目地址/，包含了项目的访问地址

之前我们配置的默认都是转发到WEB-INF下，那现在要是要转发到WEB-INF外面的login.jsp应该如何处理？

![](./01.springmvc基础.assets/16367150659469.jpg)

显式的加上forward，并添加完整路径

![](./01.springmvc基础.assets/16367150834468.jpg)

### 使用redirect来实现重定向

在浏览器进行页面的跳转，需要发送两次请求（第一次是人为，第二次是自动的）

![](./01.springmvc基础.assets/16367152036136.jpg)

使用重定向必须使用redirect，不会参与视图解析器，/ 会包含项目名，springmvc比较特殊，它会在底层给我们加上项目名，但是servlet一定要加上项目名

![](./01.springmvc基础.assets/16367152702646.jpg)

特点如下

- 地址栏的地址发生变化，显示最新发送请求的地址
- 请求次数：2次
- 请求域（request）中的数据会丢失，因为是不同的请求
- 根目录：localhost:8080/，不包含项目的名称
- 第二次请求一定是get
- 重定向不能访问到WEB-INF中的资源，因为客户端不能访问到


**转发和重定向的区别**

![](./01.springmvc基础.assets/16367155704569.jpg)

## 类型转换、数据格式化、数据验证

### 类型转换器

springmvc底层已经帮我们做好了类型装换,springmvc提供了类型转换器，我们输入的都是字符串类型，但是在后端时，我们可以用其他的数据类型来接收数据，也可以用实体来接收参数

所有的类型转换器都是继承Converter

```java
@FunctionalInterface
public interface Converter<S, T> {

	/**
	 * Convert the source object of type {@code S} to target type {@code T}.
	 * @param source the source object to convert, which must be an instance of {@code S} (never {@code null})
	 * @return the converted object, which must be an instance of {@code T} (potentially {@code null})
	 * @throws IllegalArgumentException if the source cannot be converted to the desired target type
	 */
	@Nullable
	T convert(S source);

}
```

#### 自定义类型转换器

需要明确原类型和目标类型
创建一个自定义类型转换器实现Converter

![](./01.springmvc基础.assets/16367167753988.jpg)

spring-mvc.xml中配置自定义类型转换器

![](./01.springmvc基础.assets/16367167829390.jpg)

### 数据格式化

spring提供了两个可以用于格式化数字、日期和时间的注解@NumberFormat和@DateTimeFormat，这个两个标签可以用于javabean的属性或方法上

#### @NumberFormat

@NumberFormat可以用来格式化任何的数字的基本类型（如int\long）或java.lang.Number的实例（如：BigDecimal,Integer）。

![](./01.springmvc基础.assets/16367172357215.jpg)

使用示例

1. 货币类型

![](./01.springmvc基础.assets/16367172470579.jpg)

![](./01.springmvc基础.assets/16367172913282.jpg)

![](./01.springmvc基础.assets/16367172942489.jpg)

2. 使用表达式来格式化数字

![](./01.springmvc基础.assets/16367173064563.jpg)

3. 使用转百分比，如果我们加了%，springmvc就不会乘100，如果没有加，springmvc会乘100
   ![](./01.springmvc基础.assets/16367173096598.jpg)

#### @DateTimeFormat

@DateTimeFormat可以用来格式化java.util.Date、java.util.Calendar和java.util.Long类型

配置了自定义解析需要在xml配置文件中配置

![](./01.springmvc基础.assets/16367195557869.jpg)

![](./01.springmvc基础.assets/16367195605045.jpg)

spring标签会根据DateTimeForamt格式的改变而改变

![](./01.springmvc基础.assets/16367195691814.jpg)

#### spring标签在jsp标签中的使用

引入

![](./01.springmvc基础.assets/16367196623509.jpg)

for循环：输出格式是死的：1，2，3的格式

![](./01.springmvc基础.assets/16367196737317.jpg)

输出

![](./01.springmvc基础.assets/16367196823328.jpg)

### 数据校验

数据验证一般都写在前端，用js去验证，但是会出现不安全的问题。因为浏览器可以禁用js，然后绕过验证，jsr303是Java为bean数据合法性校验提供的标准，已经升级到jsr349了，hibernate validator实现了jsr349验证注解规范的技术

#### 数据验证的使用

添加hibernate validator依赖

```xml
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>6.2.0.Final</version>
</dependency>
```

如果是使用idea开发的话，要把jar添加到web-inf中，之前有步骤的，在上面，找找

![](./01.springmvc基础.assets/16367198847180.jpg)

注解，在需要验证的Javabean的属性上面加入对应的验证注解

![](./01.springmvc基础.assets/16367198996035.jpg)

1. 可以通过自己处理错误信息的方式返回给前端提示

在需要验证的处理方法的对应javaBean参数上面加上@Valid

![](./01.springmvc基础.assets/16367200670935.jpg)

在需要验证的处理方法参数中加入BindingResult，代表我们自己处理错误，这样就不会在出现数据不符合规定的时候出现报错页面了，所有的错误信息都在BindingResult

![](./01.springmvc基础.assets/16367200751269.jpg)

将错误信息取出来，输出到jsp页面上

![](./01.springmvc基础.assets/16367200867743.jpg)

通过el表达式获取到错误信息

![](./01.springmvc基础.assets/16367200904016.jpg)

2. 也可以通过设置信息返回给前端

使用示例

![](./01.springmvc基础.assets/16367199254289.jpg)

message可以设置错误信息，当出现错误的时候，前端可以给出提示

![](./01.springmvc基础.assets/16367199292137.jpg)

因为提交的数据已经在model中了，所有直接使用value="${user.id}"进行错误回显之后显示用户提交的信息错误在哪里

![](./01.springmvc基础.assets/16367199460343.jpg)

#### spring form标签

springmvc内置了form标签可以获取到验证数据给出的错误

spring form标签库的使用相对比原来的更加方便，直接使用spring提供的标签

![](./01.springmvc基础.assets/16367203985821.jpg)

使用springmvc form标签修改上面基础的form表单为spring form表单

1. 上面的一些信息不用改，改方法就好了

![](./01.springmvc基础.assets/16367202486902.jpg)

2. 修改jsp页面，引入spring的标签库

![](./01.springmvc基础.assets/16367202832639.jpg)

所有的表单标签都需要加上form开头

![](./01.springmvc基础.assets/16367202921895.jpg)

![](./01.springmvc基础.assets/16367202956435.jpg)

![](./01.springmvc基础.assets/16367202991950.jpg)

3. spring form标签是支持put和delete提交的

服务器在编译jsp页面的都是，看到form表单中是put\delete提交，会自动在form表单中添加_method隐藏域

4. spring form标签的使用

![](./01.springmvc基础.assets/16367204306218.jpg)

## json处理

### json

JSON 是存储和交换文本信息的语法，可以用在前后端分离的项目中做传输数据之用

![](./01.springmvc基础.assets/16367206592424.jpg)

### springmvc的返回json数据

1. spring默认支持返回json数据，但是没有开启，需要添加依赖之后开启

支持json的jar包很多，这里使用jackson

jackson依赖

```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-annotations</artifactId>
    <version>2.10.3</version>
</dependency>

<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.10.3</version>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-core</artifactId>
    <version>2.10.3</version>
</dependency>
```

将jackson的jar包加入到web-inf中，并在对应的方法上加上 @ResponseBody用于标记该处理方法返回json。要注意版本问题，spring5.2.7 对应的是jackson 2.10.3，要不然出现问题

前端返回的结果

![](./01.springmvc基础.assets/16367218866897.jpg)

一种方法是在方法上添加@ResponseBody，一种方法是在类上添加RestController（相当于在所有的方法上都添加上ResponseBody）

2. 如果我们不希望password返回给前端，可以在实体类中password上加上注解

![](./01.springmvc基础.assets/16367219535553.jpg)

3. 如果我们从数据库查询到的日期时间格式不是我们想要的格式，可以使用jackson格式化

![](./01.springmvc基础.assets/16367220009389.jpg)

### springmvc获取json数据

在前端向后端发起请求的时候，可以通过ajax请求。

#### 接收参数

为了方便前端页面使用ajax，引入

![](./01.springmvc基础.assets/16367221361477.jpg)

然后辨析ajax

![](./01.springmvc基础.assets/16367221519376.jpg)

后台接收数据

![](./01.springmvc基础.assets/16367221627031.jpg)

#### 接收实体

外面是单引号，里面是双引号；或者定义一个对象，然后使用JSON.stringfy转成字符串

![](./01.springmvc基础.assets/16367222278634.jpg)


#### 接收map

直接用map接收

#### 接收list

直接用list接收

## 上传、下载

### 下载

#### 基于servlet api的下载

获取的文件名肯定是从数据库中获取的，然后从本地或者CDN获取到文件数据，以附件的形式返回到前端页面

![](./01.springmvc基础.assets/16367223643896.jpg)

#### springmvc的方式下载

**不建议使用，因为不支持缓冲区，要一次性把文件的流都传输到客户端**

![](./01.springmvc基础.assets/16367224592135.jpg)

### 上传

springmvc为文件上传提供了直接的支持，这种支持是通过即插即用的`MultipartResolver`实现的，spring用Jakarta Commons FileUpload技术实现一个`MultipartResolver`的实现类：`CommonsMultiaprtResovler`

可以通过command+shift+h快捷键查看MultipartResolver的实现类

![](./01.springmvc基础.assets/16367225880333.jpg)

为了使用CommonsMultiaprtResovler，我们添加依赖

```xml
<!-- 基于Jakarta Commons FileUpload的依赖支持 -->
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.4</version>
</dependency>
```

查看是否已经加入到web-inf/lib下

![](./01.springmvc基础.assets/16367233095073.jpg)

注入到spring容器中

```xml
<!-- id="multipartResolver" id要这个-->
<bean class="org.springframework.web.multipart.commons.CommonsMultipartResolver" id="multipartResolver">
    <property name="defaultEncoding" value="UTF-8"/>
    <!--设置最大上传 10M-->
    <property name="maxUploadSize" value="#{1024*1024*10}"/>
</bean>
```

#### 单文件上传

编写jsp页面

![](./01.springmvc基础.assets/16367233995480.jpg)

编写方法

```java
/**
 * 单文件上传
 * @param desc
 * @param myfile
 * @return
 * @throws Exception
 */
@RequestMapping("/upload")
public String upload(String desc, MultipartFile myfile) throws Exception {
    // 上传到opt/codes下
    String path="opt/codes/"+myfile.getOriginalFilename();

    File file=new File(path);
    myfile.transferTo(file);
    return "success";
}
```

#### 多文件上传

需要将form表单改成

![](./01.springmvc基础.assets/16367234608298.jpg)

1. 单线程接收文件方式

编写文件接收方法

```java
/**
 * 多文件上传
 * @param desc
 * @param myfiles
 * @return
 * @throws Exception
 */
@RequestMapping("/uploads")
public String uploads(String desc, MultipartFile[] myfiles) throws Exception {
    // 上传到opt/codes下
    for(MultipartFile myfile : myfiles){
        String path="opt/codes/"+myfile.getOriginalFilename();

        File file=new File(path);
        myfile.transferTo(file);
    }

    return "success";
}
```

2. 多线程接收文件的方式

```java
/**
 * 多线程上传
 * @param desc
 * @param myfiles
 * @return
 * @throws Exception
 */
@RequestMapping("/uploads1")
public String uploads1(String desc, MultipartFile[] myfiles) throws Exception {
    // 上传到opt/codes下
    for(MultipartFile myfile : myfiles){
        Thread thread = new Thread(() -> {
            String path = "opt/codes/" + myfile.getOriginalFilename();

            File file = new File(path);
            try {
                myfile.transferTo(file);
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
        thread.start();//启动接收线程
        thread.join();//让子线程执行完在执行主线程
    }

    return "success";
}
```

#### 文件上传应该存储在什么地方？

- 项目路径（适用于项目小，上传使用率低）
- 磁盘路径，这种方式需要通过虚拟目录映射
- 静态资源服务器（CDN、七牛云）

### 图片虚拟目录映射

如果上传文件直接上传到D盘，然后等下要显示文件要怎么写呢？我们可以通过配置Tomcat的虚拟目录来配置映射到我们存储资源的目录

#### 配置tomcat虚拟目录

Tomcat有一个虚拟目录的概念，idea中可以配置

![](./01.springmvc基础.assets/16367237443154.jpg)

![](./01.springmvc基础.assets/16367237470337.jpg)

![](./01.springmvc基础.assets/16367237498566.jpg)

这样就可以在前端页面中获取到在该目录下的资源了

![](./01.springmvc基础.assets/16367237960441.jpg)

*这里错误：img该成codes*

## 拦截器

提供了拦截器机制，运行目标方法之前进行一些拦截工作或者目标方法运行之后进行一下其他相关的处理，自定义的拦截器必须实现HandlerInterceptor接口

拦截器采用了AOP的设计思想，它跟过滤器类似，用来拦截处理方法之前和之后执行一些根主业务没有关系的一些公共功能，比如：实现登录、权限控制、日志、异常记录

自定义拦截器必须实现HandlerInterceptor接口

![](./01.springmvc基础.assets/16367242659807.jpg)


添加tomcat servlet的依赖

![](./01.springmvc基础.assets/16367242859405.jpg)

创建类实现HandlerInterceptor接口

```java
public class MyInterceptor implements HandlerInterceptor {
    /**
     * 在处理方法之前执行 日志、权限、记录调用时间做方法的优化
     * @param request 可以在方法请求进来之前更改request中的属性值
     * @param response
     * @param handler 封装来了当前处理方法的信息
     * @return 后续调用链是否执行 如果是false 则中断后续执行
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //在请求映射对应的处理方法映射，实现类才是HandlerMethod，如果是视图控制器，实现类是ParammeterizableViewController
        //也就是说，只有在请求进来的时候handler才是HandlerMethod，如果是返回去的响应的视图控制器handler就是ParammeterizableViewController，所以最好就是在强转的时候先判定
        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            System.out.println("方法名称：" + handlerMethod.getMethod().getName());
            System.out.println(Arrays.toString(handlerMethod.getMethod().getParameters()));

            System.out.println("方法前执行-------");

        }

        // 如果是return false 中断后面的执行
        return true;
    }

    /**
     * 在请求执行后执行，在视图之前执行
     * 业务方法出现异常不会执行
     * @param request
     * @param response 可以在方法执行后去更改response中的信息
     * @param handler 封装了当前处理方法的信息
     * @param modelAndView 封装了model和view，所以当请求结束后可以修改model中的数据或者新增model数据，也可以修改view的跳转
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {


        System.out.println("方法后，渲染之前执行-------");
    }

    /**
     * 在视图渲染后执行 相当于try-catch-finally 中的finally
     * 业务方法出现异常也会执行
     * @param request
     * @param response
     * @param handler
     * @param ex 异常对象，可以在该方法中做一些记录异常日志的功能 或者 清除资源
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("渲染之后执行-------");
    }
}
```

然后在springmvc配置文件中配置

```xml
<!-- 开启注解驱动，比如：配置访问静态资源-->
<mvc:annotation-driven />

<!--配置拦截器：把过滤器注入到spring容器中-->
<mvc:interceptors>
    <!--直接配置会拦截所有的请求-->
    <bean class="org.example.interceptors.MyInterceptor" id="myInterceptor"/>
</mvc:interceptors>
```

### 案例：自定义拦截器实现登录权限校验

1. login.jsp

![](./01.springmvc基础.assets/16367251409576.jpg)

2. UserController

get请求用来跳转到login.jsp，post用来登录

![](./01.springmvc基础.assets/16367251526523.jpg)

如果不想多写一个跳转的get方法，可以在springmvc配置文件中配置视图控制器，DispatcherServlet会先去控制器中找有没有对应的方法，如果没有才会去找视图控制器的配置

![](./01.springmvc基础.assets/16367252223844.jpg)

3. CheckLoginHandler

![](./01.springmvc基础.assets/16367252684891.jpg)

4. springmvc.xml配置文件中注入拦截器

```xml
<!-- 开启注解驱动，比如：配置访问静态资源-->
<mvc:annotation-driven />

<!--配置拦截器：把过滤器注入到spring容器中-->
<mvc:interceptors>
    <!--如果不是所有的请求都拦截，可以加interceptor-->
    <mvc:interceptor>
        <!--需要拦截的请求-->
        <mvc:mapping path="/**"/>
        <!--忽略的请求-->
        <mvc:exclude-mapping path="/login"/>
        <!--拦截器-->
        <bean class="org.example.interceptors.CheckLoginInterceptor" id="checkLoginInterceptor"/>
    </mvc:interceptor>

    <!--直接配置会拦截所有的请求-->
    <bean class="org.example.interceptors.MyInterceptor" id="myInterceptor"/>
</mvc:interceptors>
```

### 过滤器和拦截器的区别

过滤器先执行，然后拦截器再执行

![](./01.springmvc基础.assets/16367253906620.jpg)

![](./01.springmvc基础.assets/16367253943512.jpg)

#### 区别

1. 过滤器是基于函数回调的（调用接口实现），而拦截器是基于Java反射的（AOP）

2. 过滤器依赖于servlet容器，而拦截器不依赖与servlet容器

- 过滤器是servlet包下的
- 拦截器是spring提供的

3. 过滤器几乎对所有的请求都起作用，而拦截器只能对springmvc请求起作用
4. 拦截器可以访问处理方法的上下文，而过滤器不可以（HandlerMethod）

## 国际化（i18n）

### 关于语言的头信息

![](./01.springmvc基础.assets/16367258784626.jpg)

### 通过浏览器语言设置国际化

springmvct提供了AcceptHeaderLocaleResolver类，默认的语言配置，根据Accept-Language来设置。

1. 配置国际化的资源文件，文件中对应存储了翻译的键值对

![](./01.springmvc基础.assets/16367258952944.jpg)

2. spring.xml中配置

```xml
<!--设置国际化支持，配置国际化属性资源文件-->
<bean class="org.springframework.context.support.ResourceBundleMessageSource" id="messageSource">
    <property name="basenames">
        <array>
            <!--添加刚才配置的login页面的国际化信息-->
            <value>i18n/login</value>
        </array>
    </property>
    <!--设置防止乱码-->
    <property name="cacheSeconds" value="0"/>
    <property name="defaultEncoding" value="UTF-8"/>
</bean>
```

3. jsp上调用显示

做一个登录页面

- 可以使用jstl

- 也可以使用spring的标签库，添加spring标签库

```jsp
// 引入spring标签
<%@taglib prefix="spring" uri="http://www.springframework.org/tags" %>

// 登录页面设置国际化
<form:form class="form-signin" action="${basePath}/login" method="post" modelAttribute="user">
    <div class="text-center mb-4">
        <img class="mb-4" src="${basePath}/assets/brand/bootstrap-solid.svg" alt="" width="72" height="72">
        <h1 class="h3 mb-3 font-weight-normal"><spring:message code="txt.Login"/></h1>
        <p><spring:message code="txt.Welcome"/></p>
        <div class="row">
            <a class="col-md-6" href="${basePath}/i18n/zh_CN">中文</a>
            <a class="col-md-6" href="${basePath}/i18n/en_US">English</a>
        </div>
        <div class="row">
            <a class="col-md-6" href="${basePath}/i18n?locale=zh_CN">中文_拦截器</a>
            <a class="col-md-6" href="${basePath}/i18n?locale=en_US">English_拦截器</a>
        </div>
    </div>

    <div class="form-label-group">
        <input type="email" id="inputEmail" name="email" class="form-control" placeholder="<spring:message code="txt.Email"/>" autofocus>
        <label for="inputEmail"><spring:message code="txt.Email"/></label>
        <form:errors path="email"/>
    </div>

    <div class="form-label-group">
        <input type="input" id="inputEmail" name="birthday" class="form-control" placeholder="<spring:message code="birthday"/>" autofocus>
        <label for="inputEmail"><spring:message code="birthday"/></label>
        <form:errors path="birthday"/>
    </div>

    <div class="form-label-group">
        <input type="password" id="inputPassword" name="password" class="form-control" placeholder="<spring:message code="txt.Password"/>">
        <label for="inputPassword"><spring:message code="txt.Password"/></label>
        <form:errors path="password"/>
    </div>

    <div class="checkbox mb-3">
        <label>
            <input type="checkbox" value="remember-me"> <spring:message code="txt.Remember"/>
        </label>
    </div>
    ${errMsg}
    <button class="btn btn-lg btn-primary btn-block" type="submit"><spring:message code="txt.Login"/> </button>
</form:form>
```

使用`<spring:message code="txt.Login"/>`获取到后端的配置的国际化文件中的信息

4. 结果

中文

![](./01.springmvc基础.assets/16367266254373.jpg)

然后在浏览器设置改一下语言

![](./01.springmvc基础.assets/16367269815042.jpg)

就会改变Accept-Language成为英文

![](./01.springmvc基础.assets/16367270030965.jpg)

### 通过超链接来切换国际化

在日常工作中，如果你的网站需要给不同地区的人进行查看，此时就需要使用国际化的基本操作，springmvc的国际化操作比较容易，点击了这个页面上的中英文的按钮之后，后面的页面也是这个设置

点击了这个页面上的中英文的按钮之后，后面的页面也是这个设置，怎么保证后续的所有的页面都保持这个状态，因为请求是没有状态的。

spring提供了`org.springframework.web.servlet.i18n.SessionLocaleResolver`，里面根据这个变量`TIME_ZONE_SESSION_ATTRIBUTE_NAME`来设定语言

```java
/**
 * Name of the session attribute that holds the TimeZone.
 * Only used internally by this implementation.
 * <p>Use {@code RequestContext(Utils).getTimeZone()}
 * to retrieve the current time zone in controllers or views.
 * @see org.springframework.web.servlet.support.RequestContext#getTimeZone
 * @see org.springframework.web.servlet.support.RequestContextUtils#getTimeZone
 */
public static final String TIME_ZONE_SESSION_ATTRIBUTE_NAME = SessionLocaleResolver.class.getName() + ".TIME_ZONE";
```

在spring-mvc.xml中配置SessionLocalResolver并且名字为localResolver覆盖AcceptHeaderLocaleResolver，因为AcceptHeaderLocaleResolver是springmvc默认的语言处理器，根据Accept-Language配置

```xml
<!--使用SessionLocaleResolver会保持Locale的状态，会从session中获取Locale对象，
    覆盖springmvc配置的AcceptHeaderLocaleResolver的id为localeResolver
-->
<bean class="org.springframework.web.servlet.i18n.SessionLocaleResolver" id="localeResolver" />
```

添加中英切换按钮的切换事件

```jsp
<form:form class="form-signin" action="${basePath}/login" method="post" modelAttribute="user">
    <div class="text-center mb-4">
        <img class="mb-4" src="${basePath}/assets/brand/bootstrap-solid.svg" alt="" width="72" height="72">
        <h1 class="h3 mb-3 font-weight-normal"><spring:message code="txt.Login"/></h1>
        <p><spring:message code="txt.Welcome"/></p>
        <div class="row">
            <a class="col-md-6" href="${basePath}/i18n/zh_CN">中文</a>
            <a class="col-md-6" href="${basePath}/i18n/en_US">English</a>
        </div>
    </div>

    <div class="form-label-group">
        <input type="email" id="inputEmail" name="email" class="form-control" placeholder="<spring:message code="txt.Email"/>" autofocus>
        <label for="inputEmail"><spring:message code="txt.Email"/></label>
        <form:errors path="email"/>
    </div>

    <div class="form-label-group">
        <input type="input" id="inputEmail" name="birthday" class="form-control" placeholder="<spring:message code="birthday"/>" autofocus>
        <label for="inputEmail"><spring:message code="birthday"/></label>
        <form:errors path="birthday"/>
    </div>

    <div class="form-label-group">
        <input type="password" id="inputPassword" name="password" class="form-control" placeholder="<spring:message code="txt.Password"/>">
        <label for="inputPassword"><spring:message code="txt.Password"/></label>
        <form:errors path="password"/>
    </div>

    <div class="checkbox mb-3">
        <label>
            <input type="checkbox" value="remember-me"> <spring:message code="txt.Remember"/>
        </label>
    </div>
    ${errMsg}
    <button class="btn btn-lg btn-primary btn-block" type="submit"><spring:message code="txt.Login"/> </button>
</form:form>
```

在I18nController中编写切换语言的函数处理请求

```java
@Controller
public class I18nController {
    @RequestMapping("/i18n/{language}_{country}")
    public String changeLocale(@PathVariable("language") String language,
                               @PathVariable("country") String country,
                               @Autowired SessionLocaleResolver localeResolver,
                               HttpServletRequest request,
                               HttpServletResponse response){
        Locale local=new Locale(language,country);
        localeResolver.setLocale(request,response,local);
        return "login";
    }
}
```

结果

![](./01.springmvc基础.assets/16367280628024.jpg)

![](./01.springmvc基础.assets/16367279505229.jpg)

springmvc提供了LocaleChangeInterceptor可以实现不用自己编写切换按钮的响应事件，只要在链接中添加locale参数即可

配置拦截器

```xml
<mvc:interceptors>
    <bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor" />
</mvc:interceptors>
```

修改切换语言的按钮的链接

```jsp
<form:form class="form-signin" action="${basePath}/login" method="post" modelAttribute="user">
    <div class="text-center mb-4">
        <img class="mb-4" src="${basePath}/assets/brand/bootstrap-solid.svg" alt="" width="72" height="72">
        <h1 class="h3 mb-3 font-weight-normal"><spring:message code="txt.Login"/></h1>
        <p><spring:message code="txt.Welcome"/></p>
        <div class="row">
            <a class="col-md-6" href="${basePath}/i18n/zh_CN">中文</a>
            <a class="col-md-6" href="${basePath}/i18n/en_US">English</a>
        </div>
        <div class="row">
            <a class="col-md-6" href="${basePath}/i18n?locale=zh_CN">中文_拦截器</a>
            <a class="col-md-6" href="${basePath}/i18n?locale=en_US">English_拦截器</a>
        </div>
    </div>

    <div class="form-label-group">
        <input type="email" id="inputEmail" name="email" class="form-control" placeholder="<spring:message code="txt.Email"/>" autofocus>
        <label for="inputEmail"><spring:message code="txt.Email"/></label>
        <form:errors path="email"/>
    </div>

    <div class="form-label-group">
        <input type="input" id="inputEmail" name="birthday" class="form-control" placeholder="<spring:message code="birthday"/>" autofocus>
        <label for="inputEmail"><spring:message code="birthday"/></label>
        <form:errors path="birthday"/>
    </div>

    <div class="form-label-group">
        <input type="password" id="inputPassword" name="password" class="form-control" placeholder="<spring:message code="txt.Password"/>">
        <label for="inputPassword"><spring:message code="txt.Password"/></label>
        <form:errors path="password"/>
    </div>

    <div class="checkbox mb-3">
        <label>
            <input type="checkbox" value="remember-me"> <spring:message code="txt.Remember"/>
        </label>
    </div>
    ${errMsg}
    <button class="btn btn-lg btn-primary btn-block" type="submit"><spring:message code="txt.Login"/> </button>
</form:form>
```

结果

![](./01.springmvc基础.assets/16367288521352.jpg)

### 国际化类型转换和验证失败的信息

1. 引入hibernate-validator

```xml
<dependency>
        <groupId>org.hibernate</groupId>
        <artifactId>hibernate-validator</artifactId>
        <version>5.1.0.Final</version>
    </dependency>
```

2. User添加验证的注解

![](./01.springmvc基础.assets/16367290478360.jpg)

3. 编写UserController

![](./01.springmvc基础.assets/16367290840587.jpg)

4. 编写登录页面

![](./01.springmvc基础.assets/16367291118560.jpg)

5. 结果

![](./01.springmvc基础.assets/16367291263782.jpg)

6. 将提示中文内容修改成国际化

注入ResourceBundleMessageSource或者它的父类到UserController

![](./01.springmvc基础.assets/16367291667914.jpg)

将错误提示信息修改成配置文件

![](./01.springmvc基础.assets/16367291837549.jpg)

从配置文件中拿到提示信息

![](./01.springmvc基础.assets/16367291942678.jpg)

里面的{}（下标从0开始）的内容可以给提示的内容添加更多信息

![](./01.springmvc基础.assets/16367292170591.jpg)

![](./01.springmvc基础.assets/16367292204889.jpg)

![](./01.springmvc基础.assets/16367292240911.jpg)

结果

![](./01.springmvc基础.assets/16367292334721.jpg)

### hibernate-validator

hibernate-validator中验证信息国际化

![](./01.springmvc基础.assets/16367297334134.jpg)

这里面的是：注解.对象.属性，不是+

1. 去除User原本的注解提示信息

![](./01.springmvc基础.assets/16367297624552.jpg)

2. 添加国际化信息到配置文件

![](./01.springmvc基础.assets/16367297712792.jpg)

3. 结果

![](./01.springmvc基础.assets/16367297908992.jpg)

4. 修改Date类或者其他类转换异常时出现的错误

当Date类型转换异常的时候会出现

![](./01.springmvc基础.assets/16367298120416.jpg)

![](./01.springmvc基础.assets/16367298415000.jpg)

![](./01.springmvc基础.assets/16367299074487.jpg)

![](./01.springmvc基础.assets/16367298451377.jpg)

## 异常处理

一般把异常抛出到控制层去处理

### 内置异常处理解析器

spring提供的内置的异常处理器

![](./01.springmvc基础.assets/16367299753137.jpg)

如果想看springmvc内置的一些API，可以搜索DispatcherServlet.properties

![](./01.springmvc基础.assets/16367299831465.jpg)

![](./01.springmvc基础.assets/16367299870855.jpg)

通过这个注解做统一异常处理

![](./01.springmvc基础.assets/16367299898979.jpg)

### 统一异常处理

能处理普通请求==>视图，也可以处理ajax==>json

#### 异常处理的示例

处理异常通过这个注解ExceptionHandler转发到一个友好的界面中进行提示，如果开发人员想看报错的栈信息，可以通过

- 记录日志
- 可以将异常转发到错误页面的隐藏div中，方便程序员查看

如果ExceptionHandler写在当前@Controller中，只能处理当前Controller的错误

1. 编写方法

```java
@Controller
public class ExceptionController {

    @RequestMapping("/exception01")
    public String exception01(@RequestParam("name") String name){
        System.out.println("方法处理1.....");
        return "show";
    }

    @ExceptionHandler(Exception.class)
    public ModelAndView handleException(Exception exception){
        ModelAndView modelAndView=new ModelAndView();
        modelAndView.setViewName("error");

        modelAndView.addObject("exception",exception);

        StringWriter sw=new StringWriter();
        PrintWriter pw=new PrintWriter(sw);
        exception.printStackTrace(pw);
        System.out.println(sw.toString());// 日志记录
        return modelAndView;
    }
}
```

出现异常跳转到error.jsp文件

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
服务器出错了.....
    <!--将异常信息存储在div.display:none中，可以让开发人员获取到错误信息-->
    <div style="display: none;">
        <%=((Exception)request.getAttribute("exception")).getMessage()%>
    </div>
</body>
</html>
```

#### 全局异常处理

将处理异常的方法抽离成全局异常处理

```java
/**
 * 处理全局异常
 * ControllerAdvice是对Controller的增强，可以对Controller中被@RequestMapping注解的方法加一些逻辑处理：
 *  全局异常处理
 *  全局数据绑定
 *  全局数据预处理
 */
@ControllerAdvice
public class GeneralExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ModelAndView handleException(HttpServletRequest request, HttpServletResponse response,
                                        HandlerMethod handlerMethod,
                                        Exception exception){
        //1、根据用户请求的处理方法，是否是一个返回json的处理方法
        // handlerMethod.getClass().getAnnotation(RestController.class);//获得类上面的某个注解
        // handlerMethod.getMethod().getAnnotation(ResponseBody.class);//获得方法上面的某个注解
        //2、可以根据请求头中的类型Content-Type包含application/json;encode=UFT-8

        //如果当前请求是ajax 就返回json
        if(request.getHeader("accept").indexOf("application/json")>-1) {
            //可以直接输出json response.getWriter().write();
            // ModelAndView同时支持视图返回和json返回
            ModelAndView modelAndView =new ModelAndView(new MappingJackson2JsonView());
            //通常会根据不同异常返回不同的编码
            modelAndView.addObject("code", HttpStatus.INTERNAL_SERVER_ERROR.value());
            modelAndView.addObject("message",exception.getMessage());
            return modelAndView;
        }else{
            ModelAndView modelAndView=new ModelAndView();
            modelAndView.setViewName("error");

            modelAndView.addObject("exception",exception);

            StringWriter sw=new StringWriter();
            PrintWriter pw=new PrintWriter(sw);
            exception.printStackTrace(pw);
            System.out.println(sw.toString());// 日志记录
            return modelAndView;
        }
    }
}
```

- 如果存在全局异常和处理器异常的优先级：处理器异常优先级更高
- 如果获取的异常更小，则会被更精细的异常处理
- 因为异常是冒泡出出来的，从小到大，然后在小的被捕获了，就不会往上冒

### 配置404页面

在web下新建404.html页面

![](./01.springmvc基础.assets/16367310166849.jpg)

配置404.html不经过DispatcherServlet处理

```xml
<mvc:resources mapping="/**/*.html" location="/"/>
```

